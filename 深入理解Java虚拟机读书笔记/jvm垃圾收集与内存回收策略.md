# 垃圾收集器与内存分配

### 一.判断对象是否存活的算法:

*1.引用计数法:*

  给对象添加一个引用计数器,每一个地方引用它时计数器加１;引用失效时计数器减１.为值为０的对象不可能再被使用.
  
  缺点:<br>
  难以解决对象之间循环引用的问题（对象Ａ引用对象Ｂ，对象Ｂ引用对象Ａ，两个对象无实际意义）

*2.可达性分析算法:*

  通过一些称为"GC_ROOTS"的对象作为起点,开始向下搜索引用它的对象,这个过程走过的路径即"引用链".当一个对象到"GC_ROOTS"没有任何引用链相连,证明此对象不存活.<br>
  
  可作为GC_ROORS的对象:<br>
    1) 虚拟机栈(栈帧中的本地变量表)中引用的对象<br>
    2) 方法区中静态属性引用的对象<br>
    3) 方法区中常量引用的对象<br>
    4) 本地方法栈中JNI(Native方法)引用的对象


### 二.四种引用方式:

*1.强引用(Strong Reference):

  程序代码当中普遍存在的类似"Object obj = new Object()"这类引用.
  只要强引用存在,该对象永远不会被垃圾收集器回收.

*2.软引用(Soft Reference):*

  SoftReference类实现,用于描述还有用但非必需的对象.
  在系统将要发生内存溢出异常之前,会对这些软引用对象进行二次回收.

*3.弱引用(Weak Reference):*

  WeakReference类实现,也是用于描述非必须对象,强度比软引用更弱.
  无论内存是否足够,弱引用对象都会在下一次垃圾收集发生时进行回收.

*4.虚引用(Phantom Reference):*

  PhantomReference类实现,虚引用无法影响对象的生存时间,唯一用处是在对象被回收时收到一个系统通知.


### 三.对象死亡的判定过程:

一个对象真正被宣告死亡,至少经过两次标记过程:
  1) 第一次标记:对象经过可达性分析判定不存活

  2) 判断对象是否覆盖或者是否被调用过finalize方法.若未覆盖或已被调用则直接回收对象,否则将对象放入`F-Queue`队列中去触发finalize方法
  
  3) 第二次标记: GC对`F-Queue`中的对象进行筛选,检查对象是否在finalize()中与引用链上的对象进行关联(自救),是则被移出回收集合,否则标记
  

### 四.垃圾收集的算法:

*1.标记 - 清除算法:*<br>
  标记阶段:标记出所有需要回收的对象
  清除阶段:统一回收所有被标记的对象

  缺点:<br>
    1) 效率:标记和清除两个过程效率都不高.<br>
    2) 空间:标记清除过后会产生大量不连续的内存碎片,导致不发分配足够的连续内存给大对象而提前出发一次垃圾收集<br>
    
*2.复制算法(用于新生代):*<br>
  将可用内存按容量分为大小相等的两块,每次只使用其中一块.当一块内存用完后,将存活对象复制到另一块上,然后一次性清理使用过的空间.

  优点:<br>
    实现简单,运行高效

  缺点:
    内存缩小为一半,代价太高
    
  0) 新生代的复制算法:<br>
  将新生代内存分为一个较大的Eden和两个较小的Survivor空间,每次使用Eden和一个Survivor.<br>
  当回收时将Eden和Survivor中存活的对象一次性复制到另一块Survivor中,清理刚用过的Eden和Survivor空间.<br>
  当Survivor中不足以存放上一次存活对象时,这些对象将直接通过`分配担保机制`进入老年代.<br>

*3.标记 - 整理算法(用于老年代):*<br>
  标记阶段:标记出所有需要回收的对象
  
  整理阶段:让所有存活的对象都向一端移动,然后直接清理端边界以外的内存
  
  缺点:<br>
    整理过程耗时
    
*4.分代收集算法:*<br>
  把Java堆分为新生代和老年代,根据各个年代特点采用合适的收集算法.<br>

  新生代:每次GC都有大批对象死去,只有少量存活,故使用复制算法(实际上经过改进)<br>
  
  老年代:对象成活率高,使用标记-整理算法
  



### 五.内存的分配与回收策略(对象年龄判定):

新生代: Eden + Survivor*2<br>
Eden:Survivor = 8:1


*1) 对象优先在Eden上分配:*<br>
  每次分配可用空间为Eden+Survivor,另一个Survivor在下次垃圾收集时用于存放复制的存活对象.

*2) 长期存活的对象进入老年代:*<br>
  对象在Survivor区中每存活一次Minor GC,年龄就增加一岁,当年龄增加到一定程度(默认为15岁)就会从新生代晋升到老年代中

*3) 对象年龄的动态判定:*<br>
  如果在Survivor空间中相同年龄所有对象所占空间大于Survivor空间的一半,则大于等于此年龄的对象可以直接晋升老年代.
  

*空间分配担保:*

  老年代剩余空间 > 之前转入老年代的对象的平均大小 ---> 直接Major GC

  老年代剩余空间 < 之前转入老年代的对象的平均大小 && 允许担保失败 ---> 直接Minor GC，不需要做Full GC
  
  老年代剩余空间 < 之前转入老年代的对象的平均大小 && 不允许担保失败 ---> 触发Full GC
  

